
# 集合基础接口
	Collection		允许操作一组对象，位于集合层次结构的顶部
	
	List			扩展 Collection 以处理序列（对象列表）
	
	
	Set				扩展Collection 以处理集合，集合中的元素必须唯一
		SortedSet	扩展 Set 以处理已排序的集合
			NavigableSet		扩展 SortedSet 以基于最接近匹配原则检索元素
			
	Queue			扩展 Collection 以处理特殊类型的列表，这种类型的列表只能从列表顶部删除元素,而在表的后端进行插入操作
		Deque		扩展 Queue 以处理双端队列

	/*
		异常集合
		如果与队列中的元素不兼容，有些方法会抛出 ClassCastExcetion
		如果视图在不允许有null 元素的队列中储存 null 对象，会抛出 NullPointerExcetion
		参数无效，会抛出 IllegalStateExcetion
		试图在空队列中移除元素， 会抛出 NoSuchElementExcetion
		
	*/
	
	/*
		集合中只能储存 内置类 String Integer ... ， 或引用对象
	*/

# Collection 接口
	Collection 接口是构建集合框架的基础，集合类都实现了该接口
	Collection 扩展了 Iterable 接口，所有集合都可以使用 for-each 风格的 for 循环进行遍历
	申明： interface Collection<E>
	
	/*
		Collection c = new ArrayList();
	*/
	
	方法：
		booblean add(E obj)		将 obj 添加到集合中，添加成功返回 true,
								如果 obj 已经是集合的成员并且集合的元素不允许重复 返回false
		
		booblean addAll(Collection<? extends E> c)	将 c中的所有元素添加到调用集合中。如果调用集合发生了变化 返回true, 否则返回false
		clear() 移除调用集合中所有元素
		booblean contains(Object obj)
		booblean containsAll(Collection<?> c) 		调用集合是否包含c的所有元素
		
		booblean equals(Object obj)
		int hashCode()
		int size()						返回调用集合中元素的数量
		
		booblean isEmpty()
		booblean remove(Object obj)		返回移除集合中元素是否成功
		booblean removeAll(Collection<?> c) 	删除调用集合c的所有元素， 如果调用集合发生了变化 返回true, 否则返回false
		
		Iterator<E> iterator()			返回调用集合的一个迭送器
		default Spliterator<E> spliterator()	返回调用集合的 spliterator
		
		Object[] toArray()				返回包含调用集合中储存的所有元素的数组，数组元素是集合元素的副本
		<T> T[] toArray(T array[])		返回包含调用集合中元素的数组。数组 元素是集合元素的副本
										如果 array 长度等于元素的数量，就将返回的元素保存在array中
										小于， 则分配必需大小的新数组，并返回这个新数组
										大于， 多余的为null
										如果类型不匹配 ArrayStoreException
	
# List 接口
	用来储存一连串元素的集合，在列表中可以使用从0开始的索引，通过元素的位置插入或访问，元素可以重复。
	List 是泛型接口，其申明如下:
	interface List<E>
	除了Conllection 定义的方法外，List 还定义了自己的一些方法：
		void add(int index, E obj)  将 obj 插入指定的位置
		booblean addAll(int index, Collection<? extends E> c)
		E get(int index)
		int indexOf(Object obj) 						放回列表中第一个 obj 实例的索引。若没有找到，返回-1
		int lastIndexOf(Object obj)
		
		ListIterator<E> listIterator()
		ListIterator<E> listIterator(int index)
		
		E remove(int index)
		E set(int index, E obj)
		default void sort(Comparator<? super E> comp) 	使用comp指定的比较器排序列表
		List<E> subList(int start, int end) 			返回位置在start到 end-1, 返回的元素任然是调用对象的引用
		
		default void replaceAll(UnaryOperator<E> opToApply)
														使用 opToApply 函数获得的值更新列表中的每个元素
	
# Set 接口
	扩展了Collection 接口，不允许集合中有重复元素的组行为。如果为组添加重复的元素，add() 方法返回 false。
	Set 没有定义自己的其它方法，Set为泛型接口 
	声明如下：
	interface Set<E>
	
	
# SortedSet 接口
	SortedSet 扩展了 Set 接口， 并且声明了以升序进行排序的组行为。
	SortedSet 为泛型接口
	声明如下：
	interface SortedSet<E>
	
	SortedSet 定义了自己的一些方法：
		Comparator<? super E> comparator()		返回以排序调用组的比较器。如果是自然排序 就返回 null
		E first()
		E last()
		SortedSet<E> headSet(E end)				返回小于 end 的元素， 对于返回的已排序组中的元素，也将被以排序调用组引用
		
		SortedSet<E> subSet(E start, E end)		返回 start 与 end-1 之间的元素, 返回组中的元素也将被调用对象引用
		SortedSet<E> tailSet(E start)			返回 >= start 的元素, 返回组中的元素也将被调用对象引用
		
# NavigableSet 接口	
	NavigableSet 扩展了 SortedSet 接口, 并且该接口申明了支持基于最接近匹配原则检索元素的集合行为。
	NavigableSet 是泛型接口，其申明如下：
	interface NavigableSet<E>
	
	NavigableSet 定义了自己的一些方法：
		E ceiling(E obj)		在组中查找 >= obj的最小元素， 没有找到返回 null
		E floor(E obj)			在组中查找 <= obj的最大元素
		E higher(E obj)			在组中查找 > obj的最大元素
		E lower(E obj)			在组中查找 < obj的最大元素
		
		E pollFirst()			返回第一个元素，在操作过程中删除该元素， 组为空 返回 null
		E pollLast()
		
		Iterator<E> desendingIterator()		返回一个从最大元素向最小元素移动的迭送器。
		
		NavigableSet<E> descendingSet()		返回来翻转调用组的 NavigableSet 对象。结果基于调用组
		NavigableSet<E> headSet(E upperBound, booblean include)  	返回小于upperBound 的元素， include 为是否包含等于 upperBound 那个元素
		NavigableSet<E> subSet(E lowBound, booblean lowIncl, E upperBound, boolean highIncl)
		SortedSet<E> tailSet(E start, booblean include)				返回大于upperBound 的元素
		
	
# Queue 接口
	Queue扩展了 Collection 接口，并申明了队列的行为， 队列通常是先进先出的列表
	Queue 是泛型接口，其申明如下：
	interface Queue<E>
	
	
	boolean offer(E obj) 试图将 obj 添加到队列中。添加成功 返回true
	
	E element()	返回队列的头部的元素，队列为空 NoSuchElementExcetion
	E peek() 	返回队列的头部的元素, 队列为空返回 null
	
	E poll()	返回队列的头部的元素, 队列为空返回 null, 移除该元素
	E remove()	返回队列的头部的元素, 如果队列为空 NoSuchElementExcetion , 移除该元素
	
# Deque 接口
	
	Deque 扩展了 Queue接口，并且申明了双端队列的行为
	
	Deque 是泛型接口，其申明如下：
	interface Deque<E>
	
	void addFirst(E obj)		如果队列已满，抛出 IllegalStateExcetion
	void addLast(E obj)
	
	booblean offerFirst(E obj)	如果向 满队列 添加 obj 返回false
	booblean offerLast(E obj)
	
	
	Iterator<E> descendingIterator()			返回一个从双端队列尾部向头部移动的迭送器
	
	E getFitst()				如果队列为空 NoSuchElementExcetion
	E getLast()
	
	E peekFirst()				队列为空 返回 null
	E peekLast()
	
	E pollFirst()				队列为空 返回 null, 在队列中删除头部元素，
	E pollLast()
	
	E pop()						删除队列中头部元素， 队列为空 NoSuchElementExcetion
	E removeFirst()				删除队列中头部元素， 队列为空 NoSuchElementExcetion
	E removeLast()
	
	void push(E obj)			向队列头部添加元素， 如果队列满，则抛出 IllegalStateExcetion
	
	booblean removeFirstOccurrence(Object obj)	在队列中移除第一次出现 obj 对象。 如果队列中不包含 obj 就返回 false
	booblean removeLastOccurrence(Object obj)
	
	
# 集合类 --------------------------------------------------------------------------------------

	AbstractCollection			实现了 Collection 接口的大部分
		AbstractList			扩展AbstractCollection 类， 并实现了 List 接口大部分
			ArrayList			实现动态数组, 查询速度快，增删慢。
			AbstractSequentialList	用于顺序访问而不是随机访问集合中的元素
				LinkedList				实现了List Queue Deque 接口，使用了链表数据结构实现的, 查询速度慢，增删快。

				
		AbstractQueue			扩展AbstractCollection 类， 并实现了 Queue 接口大部分
			PriorityQueue			支持基于优先级的队列, 实现了 Queue 接口
			
		ArrayDeque				扩展AbstractCollection 类， 并实现了 Deque， 实现动态双端队列
		
		AbstractSet				扩展AbstractCollection 类，	并实现了 Set 接口大部分
			TreeSet					实现了 NavigableSet 接口， 如果元素具备自然顺序 的特性，那么就按照元素自然顺序的特性进行排序存储。
			EnumSet					用于enum 元素，实现了 Set 接口
			HashSet					底层是使用了哈希表来支持的，特点： 存取速度快, 实现了 Set 接口 
				LinkHashSet				允许按照插入的顺序进行迭代
		
	
# ArrayList	类 
	支持能够按需增长的动态数组
	class ArrayList<E>
	
	ArrayList()
	ArrayList(Collection(? extends E) c)
	ArrayList(int capacity)
	
	/*
		可以调用 ensureCapacity()方法以手动增长 ArrayList对象的容量， 以免不必要的内存分配次数可以提高性能
	*/
	
# LinkedList 类
	class LinkedList<E>

	LinkedList()
	LinkedList(Collection(? extends E) c)
	

# HashSet 类
	class HashSet<E>
	HashSet 扩展了AbstractSet 并实现了Set 接口，该类用于创建是使用哈希表存储元素的集合
	
	HashSet()
	HashSet(Collection(? extends E) c)
	HashSet(int capacity)
	HashSet(int capacity, float fillRatio)		fillRatio 填充率 决定了哈希组被填充到什么程度就增加容量，当元素数量大于哈希族
												的容量与填充率的乘积
# LinkHashSet
	LinkHashSet 扩展了 HashSet类
	class LinkHashSet<E>
	
	构造函数与HashSet的构造函数对应
	LinkHashSet 维护组中条目的一个链表，链表中条目的顺序也就是插入他们的顺序，这使得可以按照插入顺序迭代集合
	
# TreeSet 类
	TreeSet 扩展了 AbstractSet 类 并实现了 NavigableSet 接口，用于创建使用树进行存储的组。
	对象以升序存储，访问和检索速度相当快，这使得对于储存大量的、必须能够快速查找到的有序信息来说，TreeSet 是极佳的选择 
	
	TreeSet()
	TreeSet(Collection(? extends E) c)
	TreeSet(Comparator(? super E) comp)
	TreeSet(Sortedset<E> ss)
	
# PriorityQueue
	class PriorityQueue<E>
	
	PriorityQueue 扩展了 AbstractQueue 类, 并实现了 Queue 接口.
	用于创建根据队列的比较器来判定有限次序的队列，
	PriorityQueue是动态的，按需增长的。 起始容量是11
	
	PriorityQueue()
	PriorityQueue(int capacity)
	PriorityQueue(Comparator(? super E) comp)
	PriorityQueue(int capacity, Comparator(? super E) comp)
	PriorityQueue(Collection(? extends E) c)
	PriorityQueue(PriorityQueue(? extends E) c)
	PriorityQueue(Sortedset(? extends E) c)

	Comparator<? super E>comparator() 	该方法返回比较器，如果调用队列使用的是自然顺序，那么返回 null
	
	/*
		尽管可以使用迭代器遍历 PriorityQueue，但是迭代的顺序是不确定的。
		为了正确使用 PriorityQueue，必须使用 offer() 和 poll() 这类方法
	*/

# ArrayDeque 类
	扩展AbstractCollection 类， 并实现了 Deque，没有添加自己的方法
	ArrayDeque是动态数组，没有容量限制
	class ArrayDeque<E>
	
	ArrayDeque()
	ArrayDeque(int size)
	ArrayDeque(Collection(? extends E) c)

# EnumSet 类
	EnumSet<E extends Enum<E>>

	EnumSet 类 扩展了AbstractSet 类并并实现了Set 接口，专门用于枚举类型的元素，
	所有方法都有肯能抛出 NullPointerException 异常，copyOf() 和range() 方法还可能抛出 IllegalStateExcetion
	
	static <E extends Enum<E>> EnumSet<E> 
		allOf(Class<E> t)			创建的 EnumSet 包含由t 指定的枚举中的元素
		complementOf(EnumSet<E> e)	创建的 EnumSet 由未储存在e 中的元素组成
		copyOf(EnumSet<E> c)		根据 c 中存储的元素创建 EnumSet
		noneOf(Class<E> t)			创建的EnumSet 不包含由t指定的枚举中的元素
		of(E v)						创建的 EnumSet 包含 v
		/*
			of(E v,E v2,E v3 ,...)
		*/
		range(E start, E end)		创建的 EnumSet包含指定范围（由start 和end 指定）内的元素
	
	
	
# 迭代器 -------------------------------------------------------------------------------------------	
	interface Iterator<E>
	interface ListIterator<E>
	Iterator 接口允许遍历集合,获取或移除元素
	ListIterator 接口扩展了Iterator接口，允许双向遍历列表，并且允许修改元素
	
	/*
		当使用只读的集合时， remove() 方法会抛出 UnsupportedOperationException 异常
		
		可以通过 
			while(iterator.hasNext)
		
		for-each 循环替代 迭代器，for-each循环遍历任何实现了Iterator 接口的集合对象，所有集合类都实现了这个接口
			
			for(int v: collection)
	*/
	
	Iterator 接口方法：
		default void forEachRemaining(Consumer<? super E> action)		对于集合中每个未处理的元素，执行 action 指定的动作
		booblean hasNext() 		如果还有更多的元素，就返回 true, 否则返回 false
		E next()				返回下一个元素， 没有则抛出 NoSuchElementExcetion
		default void remove		移除当前元素。 如果在调用next() 方法之前视图调用remove() 方法，就会抛出 IllegalStateExcetion
							默认版本抛出 UnsupportedOperationException
							
	ListIterator 接口方法：
		void add(E obj)			将 obj 插入到列表中， 新插入的元素位于下一次 next() 方法调用返回的元素之前
	
		booblean hasPrevious()	如果存在前一个元素，就返回true; 否则返回false
		E previous()			返回前一个元素， 没有则抛出 NoSuchElementExcetion
		int nextIndex()			返回下一个元素的索引，如果不存在下一个元素，就返回列表的大小
		int previousIndex()		返回前一个元素的索引如果不存在，就返回-1
		void remove				从列表中移除当前元素。如果在调用next() 或 previous() 方法之前调用,就会抛出 IllegalStateExcetion
		void set（E obj）		将 obj 的值赋给当前元素，也就是next() 或 previous() 方法调用最后放回的元素
	
# Spliterator 接口
	Spliterator 支持并行迭代序列的一部分， 支持并行编程，
	它将hasNext 和 next 操作合并到一个方法中，从而提高效率
	
	Spliterator 定义的方法
		int characteristics()		返回调用 spliterator的特征，该特征被编码为整数
		long estimateSize()			估计剩余的要迭代的元素数
		default void forEachRemaining(Consumer<? super E> action)		对于集合中每个未处理的元素，执行 action 指定的动作
		booblean tryAdvace(Consumer<? super E> action)	在迭代中的下一个元素上执行 action, 如果有下一个元素返回true，否则 返回false
		
		default Comparator<? super T> getComparator()	返回调用spliterator 使用的比较器；如果使用了自然顺序，就返回null
														如果未被排序就抛出 IllegalStateExcetion 异常
		default long getExactSizeIfKnown		如果调用 spliterator 是 SIZED， 就返回剩余的要迭代的元素数，否则返回 false
		default booblean hasCharacteristics(int val)	如果val 中传递了调用 spliterator 的特征，返回true; 否则 返回false
		Spliterator<T> trySplit()		在操纵成功时，原 spliterator 会迭代序列的一部分，返回的 spliterator 迭代序列的其它部分
	
	/*
		Consumer 是一个函数是接口，向对象应用一个动作，
		Consumer 仅指定了一个抽象方法accept()
		 void accept(T objRefef)
		 
		对于 tryAdvance() 每次迭代会将序列中的下一个元素传递给 objRefef, 通常实现Consumer 最简单的方式是使用 lambda 表达式
		
		while(spliterator.tryAdvance( (n)->{ } ))
		
		spliterator.forEachRemaining( (n)->{ } )
	*/
	
# RandomAccess 接口
	RandomAccess 不包含成员，它支持高校地随机访问其中的元素。
	ArrayList 和遗留 的Vector 类实现了 RandomAccess 接口
	
	
	

# 映射接口 ---------------------------------------------------------------------------------------------------------
	Map				将唯一键映射到值
	Map.Entry		描述映射中的元素（键/值对），这是Map 的内部类
	NavigableMap	扩展 SortedMap 接口，以处理基于最接近匹配原则的键/值对索引
	SortedMap		扩展 Map 接口，从而以升序保存键
	
	/*
		映射是存储键和值之间关联关系（键值对）的对象。给定一个键就可以找到对应的值，
		键必须唯一，值可以重复。 某些映射可以接受 null 键 和null 值
		它们没有实现 Iterator 接口， 所以不能使用 for-each 循环遍历映射，
		但是可以获取映射的集合视图，集合视图允许使用 for-each循环 和迭送器
		
	*/
	
	
# Map 接口
	interface Map<K, V>
	
	/*
		对象与映射中的元素不兼容时，有些方法会抛出 ClassCastExcetion
		如果视图为不允许使用 null 对象的映射使用 null 对象，会抛出 NullPointerException 
		如果驶入修改不允许修改的映射，抛出 UnsupportedOperationException
		如果使用参数非法， 抛出 IllegalStateExcetion
	*/
	
	void clear()			移除映射中所有的键/值对
	default V compute(K k,
		BiFunction<? super K, ? super V, ? extends V> func
	)						调用func 以构造一个新值，如果 func 的返回值不是null,就把新的键值对添加到映射中，移除原来的配对，并返回新值
							如果 func 返回null ,就移除原来的配对 并返回null
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
# 映射类
	AbstractMap		实现了Map 接口的大部分
		EnumMap		.扩展了 AbstractMap，以使用enum 键
			/*
				class EnumMap<K extends Enum<K>,V>
			*/
			
		HashMap		.扩展了 AbstractMap，以使用哈希表
			LinkHashMap	.扩展了 HashMap，以允许按照插入顺序进行迭代
			
		TreeMap		.扩展了 AbstractMap，并实现了 NavigableMap 接口。以使用树结构
		WeakHashMap	.扩展了 AbstractMap，以使用带有弱键的哈希表
		IdentityHashMap .扩展了 AbstractMap，实现了 Map 接口。并且当比较文档时使用引用相等性
	


# 比较器
	Comparator 是泛型接口，其申明如下
	interface Comparator<T>






































































































