
# 事务隔离级别
	
	隔离级别			脏读	不可充读	幻想读 		第一类丢失更新		第二类丢失更新
	
	READ UNCOMMITED		允许	允许		允许		不允许				允许
	READ COMMITED		不允许	允许		允许		不允许				允许
	REPEATABLE READ 	不允许	不允许		允许		不允许				不允许
	SERIALIZABLE		不允许	不允许		不允许		不允许				不允许
	
	
# JDBC 对事务的支持
	并不是所有的数据库都支持事务，即使支持事务的数据库也并非支持所有的事务隔离级别。
	用户可以通过 Connection#getMetaData() 方法获取 DatabaseMetaData 对象，并通过该对象的 supportsTransactions()、supportsTransactionIsolationLevel(int level) 方法查看底层数据库的事务支持情况
	
	Connection 
		setAutoCommit(false)			默认情况下是自动提交的，每条执行的 SQL 语句都对应一个事务。
										为了将多条 SQL 语句当成一个事务执行，阻止 Connection 自动提交
										
		setTransactionIsolation() 		设置事务的隔离级别
		commit()						提交事务
		rollback()						回滚事务
	
	
	/*
		Connection conn;
		try{
			conn = DriverManager.getConnection();
			conn.setAutoCommit(false);
			conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
			Statement stmt = conn.createStatement();
			
			int rows = stmt.executeUpdate(..);
			rows = stmt.executeUpdate(..);
			
			conn.commit();
		}catch(Exception e){
		
			conn.rollback();
		}
	*/
	
	JDBC 3.0 中 引入了全新的保存点特性， Savepoint 接口允许用户将事务分割为多个阶段，用户可以指定回滚到事务的特定保存点，而并非 像JDBC 2.0 一样只能回到回滚事务到开始事务的点
	/*
		Statement stmt = conn.createStatement();
			
		int rows = stmt.executeUpdate(..);
		
		Savepoint point1 = rows.setSavepoint('savePoint1');
		rows = stmt.executeUpdate(..);
		
		conn.rollback(point1);
		conn.commit();
	*/
	
	
# ThreadLocal
	ThreadLocal 不是一个线程，而是保存线程本地化对象的容器。当运行多线程的某个对象使用 ThreadLocal 维护变量时，ThreadLocal 为每个使用该变量的线程分配一个独立的变量副本。
	所以每个线程都可以独立地改变自己的副本，而不会影响其他线程所对应的副本。
	
	* 在 ThreadLocal 类中有一个 Map, 用于储存每个线程的变量副本， key 为当前线程对象， 值为对应线程的变量副本。
	
	InheritableThreadLocal 继承与 ThreadLocal， 它自动为子线程复制一份从父线程那里继承而来的本地变量：在创建子线程时，子线程会接受所有可继承的线程变量自动传送给所有穿件的子线程时，应尽可能使用 InheritableThreadLocal
	
	泛型类： ThreadLocal<T>
	
	
	方法：
		void set(Object value)			设置当前线程的 线程局部变量的值
		public Object get()				返回当前线程所对应的线程局部变量
		public void remove()			将当前线程局部变量的值删除，目的时为了减少内存的占用。 
										当线程结束后，对应的线程的局部变量将被自动被回收， 所以显示调用该方法不是必须的
		
		protected Object initialValue()	返回该线程局部变量的初始值，该方法是一个 protected 的方法， 为让子类覆盖而设计的
	
	
	示例：
		public class SequenceNumber{
			private static ThreadLocal<Integer> seqNum = new ThreadLocal<Integer>(){
				public Integer initialValue(){
					return 0;
				}
			};
			public int getNextNum(){
				seqNum.set(seqNum.get()+1);
				return seqNum.get();
			}
			public static void main(String[] args){
				TestDome sn1 = new TestDome();
				TestDome sn2 = new TestDome();
				
				// sn1 sn2 运行互不干扰
				System.out.println(sn1.getNextNum());
				System.out.println(sn2.getNextNum());
				System.out.println(sn1.getNextNum());
				System.out.println(sn2.getNextNum());
				System.out.println(sn1.getNextNum());
				System.out.println(sn2.getNextNum());
			}
		}
	
	
. 将非线程安全成员变量保存在 ThreadLocal 中,
	public class TopicDao{
		// 使用 ThreadLocal 保存 Connection 变量
		private static ThreadLocal<Connection> connThreadLocal = new ThreadLocal<Connection>();
		
		public static Connection getConnection(){
			if(connThreadLocal.get() == null){
				Connection conn = ConnectionManager.getConnection();
				connThreadLocal.set(conn);
				return conn;
			}else{
				return connThreadLocal.get();
			}
		}
		
		public void addTopic() throws SQLException{
			// 从 ThreadLocal 中获取线程对应的 Connection
			Statement stat = getConnection().createStatement();
		}
		
	}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	